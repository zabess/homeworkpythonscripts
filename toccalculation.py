#! /usr/bin/env python
#This script imports a specified .txt file of data generated by a
#Shimadzu TOC-V analyzer. The user specifies the text file to be imported
#as well as the name of the outgoing file. The Shimadzu TOC-V analyzer
#is cabable of measuring total carbon (ppm), organic carbon (ppm) with
#the addition of acid that converts carbonate to carbon dioxide, and total
#nitrogen (ppb). This code uses the readings generated from the standards
#for each chemical species and creates a least squares regression between the
#concentration (x-axis) and area (y-axis) for the standards and calculates
#the R-squared for this calibration curve. The line of best fit from this
#calibration curve is used to calculate the concentration of each of the
#chemical for each sample. If the calculated concentration is below detection
#limit (a negative number), the code will return a 0 for that calculation.
#The code also calculates the concentration of inorganic carbon (ppm) by
#calculating the difference between total carbon and organic carbon for each
#sample. The output of the code is a .csv file containing the total carbon,
#organic carbon, inorganic carbon, and total nitrogen for each sample as well
#as the R-squared values for the calibration curves.

import math
#Import math module
#InFileName = input("Enter file name:")
#InFile = open(InFileName, 'r')
FileName = input("Enter raw data file name & extension:")
#Asks the user to input the name of the raw data file. This
#assumes the current working directory is the same as the
#location of the file.
OutFileName = input("Enter file name & extension for outgoing data:")
#Asks the user to input the name of the outgoing data file.
#This file will be in the same directory as the current working
#directory.
InFile = open(FileName, 'r')
#Read in the .txt produced by the Shimadzu TOC-V analyzer.
OutFile = open(OutFileName, 'w')

#The following section of the code extracts from the .txt document
#the information that will be used for the calibration curves.
LineNumber = 1
#Establish line counter as 1.
TCCalibrationDataxaxis = []
#Initialize a list to store the x-axis values (from the Concentration field)
#for the total carbon calibration curve. These values were input by the
#user while using the analyzer.
TCCalibrationDatayaxis = []
#Initialize a list to store the y-axis values (from the Area field)
#for the total carbon calibration curve.
NPOCCalibrationDataxaxis = []
#Intialize a list to store the x-axis values (from the Concentration field)
#for the organic carbon calibration curve.
NPOCCalibrationDatayaxis = []
#Initialize a list to store the y-axis values (from the Area field)
#for the organic carbon calibration curve.
TNCalibrationDataxaxis = []
#Initialize a list to store the x-axis values (from Concentration field)
#for the total nitrogen calibration curve.
TNCalibrationDatayaxis = []
#Initialize a list to store the y-axis values (from the Area field)
#for the total nitrogen calibration curve.
for Line in InFile:
#for each line in the incoming file:
	if LineNumber < 14:
	#if the LineNumber is less than 14, then it is part of the
	#information included at the top of the .txt file and is not
	#important,
		pass
		#and it is passed over.
	elif LineNumber == 14:
	#if the LineNumber is 14, then it is the header row
		Line = Line.strip("\n")
		#The end-of-line break is stripped.
		Line = Line.split("\t")
		#The line is broken into list elements based upon the
		#placement of tabs (input file is tab-delimited).
	else:
	#if LineNumber is greater than 14, it contains information from
	#measurements made by the machine
		Line = Line.strip("\n")
		#The end-of-line break is stripped.
		Line = Line.split("\t")
		#The line is broken into list elements based upon the
		#placement of tabs.
		if Line[1]=="TC" and Line[2]=="CALIBRATION":
		#if the Analysis is TC and the Sample Name is CALIBRATION:
			TCCalibrationDatayaxis.append(Line[11])
			#It uses the Area value from that row and appends
			#it to the list of y-axis values.
			TCCalibrationDataxaxis.append(Line[12])
			#It uses the Concentration value from that
			#row and appends it to the list of x-axis values.
		if Line[1]=="NPOC" and Line[2]=="CALIBRATION":
		#if the Analysis is NPOC and the Sample Name is CALIBRATION:
			NPOCCalibrationDatayaxis.append(Line[11])
			#It uses the Area value from that row and appends
			#it to the list of y-axis values.
			NPOCCalibrationDataxaxis.append(Line[12])
			#It uses the Concentration value from that row
			#and appends it to the list of y-axis values.
		if Line[1]=="TN" and Line[2]=="CALIBRATION":
		#if the Analysis is TN and the Sample Name is CALIBRATION:
			TNCalibrationDatayaxis.append(Line[11])
			#It uses the Area value from that row and appends
			#it to the list of y-axis values.
			TNCalibrationDataxaxis.append(Line[12])
			#It uses the Concentration value from that row
			#and appends it to the list of x-axis values.
	LineNumber = LineNumber + 1
	#With each iteration of the loop, the linenumber is reset.
TClist = [list(map(float, TCCalibrationDataxaxis)), list(map(float, TCCalibrationDatayaxis))]
#The x-axis values and y-axis values for the total carbon calibration curve
#are joined into one list of floating values.
NPOClist = [list(map(float, NPOCCalibrationDataxaxis)), list(map(float, NPOCCalibrationDatayaxis))]
#The x-axis values and y-axis values for the organic carbon calibration curve
#are joined into one list of floating values.
TNlist = [list(map(float, TNCalibrationDataxaxis)), list(map(float, TNCalibrationDatayaxis))]
#The x-axis values and y-axis values for the total nitrogen calibration curve
#are joined into one list of floating values.

#The following section of code will calculate the slope, y-intercept, and R-squared for the
#total carbon calibration curve.
product = []
#Initialize a list to store the products calculated for the slope of line of
#best fit (least squares regression).
squaredifference = []
#Initialize a list to store the squared differences calculated for the slope
#of the line of best fit.
counter = 0
#Establish the initial counter as 0.
for i in TClist[0]:
#for each x-axis value stored in TClist:
	averagexaxis = (sum(TClist[0])/len(TClist[0]))
	#Calculates the average x-axis value
	storagex = i - averagexaxis
	#Calculates the difference between the specific value and the average
	storagey = None
	#Initializes a variable to store the difference between each y-axis
	#value and the average y-axis value.
	squaredifference.append(storagex*storagex)
	#Calculates the square of the storagex value.
	averageyaxis = (sum(TClist[1])/len(TClist[1]))
	#Calculates the average of the y-axis value.
	storagey = (TClist[1][counter]) - averageyaxis
	#Calculates the difference between each y-axis value and
	#the average y-axis value.
	product.append(storagey * storagex)
	#Multiply the storagey and storagex variables for each row.
	counter = counter + 1
	#Reset the counter line for the next iteration of the for loop.
slopeTC = sum(product)/sum(squaredifference)
#Calculate the slope for the total carbon calibration curve.
yintTC = (sum(TClist[1])/len(TClist[1])) - (slopeTC*(sum(TClist[0])/len(TClist[0])))
#Calculate the y-intercept for the total carbon calibration curve.
counter = 0
#Establish line counter in for loop used for calculating the R-squared value.
n = len(TClist[0])
#Store the number of values used for the calibration curve as variable n.
productofxandy = []
#Initialize a list to store the produce of x and y values.
xs = []
#Initalize a list to store the x values.
ys = []
#Initialize a list to store the y values.
xsquared = []
#Intialize a list to store the squares of the x values.
ysquared = []
#Initialize a list to store the squares of the y values.
for i in TClist[0]:
#for each point in the calibration curve:
	productofxandy.append(TClist[0][counter]*TClist[1][counter])
	#Calculate the product of x and y dimensions
	xs.append(TClist[0][counter])
	#Append the x value to the list of x-values.
	ys.append(TClist[1][counter])
	#Append the y value to the list of y-values.
	xsquared.append((TClist[0][counter])*(TClist[0][counter]))
	#Calculate the square of the x value.
	ysquared.append((TClist[1][counter])*(TClist[1][counter]))
	#Calculate the square of the y value.
	counter = counter + 1
	#Reset the counter line for the next point.
rsquaredTC = (((n*sum(productofxandy))-(sum(xs)*sum(ys)))/math.sqrt(((n*sum(xsquared))-(sum(xs)*sum(xs)))*((n*sum(ysquared))-(sum(ys)*sum(ys)))))**2
#Calculate the R-squared value now that information has been assessed from each point.

#The following section of code will calculate the slope, y-intercept, and R-squared
#with the least squares regression method for the NPOC calibration data.
product = []
#Initialize a list to store the products used in calculating the slope.
squaredifference = []
#Initialize a list to store the differences of the squares used in
#calculating the slope.
counter = 0
#Establish the initial line counter as 0.
for i in NPOClist[0]:
#for each x-value in the organic carbon data:
        averagexaxis = (sum(NPOClist[0])/len(NPOClist[0]))
	#Calculate the average of the x values.
        storagex = i - averagexaxis
	#Calculate the difference between each x value
	#and the average of the x values.
        storagey = None
	#Initialize a variable to store the difference between
	#each y value and the average of the y values.
        squaredifference.append(storagex*storagex)
	#Append the square of the storagex value
	#to the squaredifference list.
        averageyaxis = (sum(NPOClist[1])/len(NPOClist[1]))
	#Calculate the average of the y values.
        storagey = (NPOClist[1][counter]) - averageyaxis
	#Calculate the difference between the y values and
	#the average of the y values.
        product.append(storagey * storagex)
	#Calculate the produce of the storagey and storagex
	#variables.
        counter = counter + 1
	#Reset the counter line.
slopeNPOC = sum(product)/sum(squaredifference)
#Calculate the slope of the NPOC line of best fit.
yintNPOC = (sum(NPOClist[1])/len(NPOClist[1])) - (slopeNPOC*(sum(NPOClist[0])/len(NPOClist[0])))
#Calculate the y-intercept of the NPOC line of best fit.
counter = 0
#Initialize a counter for determining R-squared value.
n = len(NPOClist[0])
#Store the number of values used in the calibration curve as
#variable n.
productofxandy = []
#Initialize a list to store the products of the x and y values.
xs = []
#Initialize a list to store the x values.
ys = []
#Initialize a list to store the y values.
xsquared = []
#Initialize a list to store the square of each of the x values.
ysquared = []
#Initialize a list to store the square of each of the y values.
for i in NPOClist[0]:
#for each point in the NPOC calibration data:
	productofxandy.append(NPOClist[0][counter]*NPOClist[1][counter])
        #Calculate the product of the x and y dimensions.
	xs.append(NPOClist[0][counter])
	#Append the x value in the xs list.
	ys.append(NPOClist[1][counter])
	#Append the y value in the ys list.
	xsquared.append((NPOClist[0][counter])*(NPOClist[0][counter]))
        #Calculate the square of the x value.
	ysquared.append((NPOClist[1][counter])*(NPOClist[1][counter]))
	#Calculate the square of the y value.
	counter = counter + 1
	#Reset the counter value for the next iteration of the loop.
rsquaredNPOC = (((n*sum(productofxandy))-(sum(xs)*sum(ys)))/math.sqrt(((n*sum(xsquared))-(sum(xs)*sum(xs)))*((n*sum(ysquared))-(sum(ys)*sum(ys)))))**2
#Calculate the R-squared value for the organic carbon calibration data.

#The following section of code calculates the slope, y-intercept, and
#R-squared value for the Total Nitrogen calibration values.
product = []
#Initialize a list to store the products used to calculate the slope
#in a least squared regression.
squaredifference = []
#Initialize a list to store the squared values used to the
#calculate the slope in a least squared regression.
counter = 0
#Initialize a counter for the loop used below to calculate
#slope and y-intercept with the Total Nitrogen calibration
#information.
for i in TNlist[0]:
#for each x value in the Total Nitrogen calibration values:
	averagexaxis = (sum(TNlist[0])/len(TNlist[0]))
	#Calculate the average of the x values.
	storagex = i - averagexaxis
	#Calculate the difference between each x value
	#and the average of the x values.
	storagey = None
	#Initialize a variable to store the difference
	#between each y value and the average of the y
	#values.
	squaredifference.append(storagex*storagex)
        #Calculate the square of the storagex value.
	averageyaxis = (sum(TNlist[1])/len(TNlist[1]))
        #Calculate the average of the y values.
	storagey = (TNlist[1][counter]) - averageyaxis
        #Calculate the difference between each y value
	#and the average of the y values.
	product.append(storagey * storagex)
        #Calculate the product of storagey and storagex
	#variables.
	counter = counter + 1
	#Reset the counter for the next iteration of
	#the loop.
slopeTN = sum(product)/sum(squaredifference)
#Calculate the slope of the line of best fit.
yintTN = (sum(TNlist[1])/len(TNlist[1])) - (slopeTN*(sum(TNlist[0])/len(TNlist[0])))
#Calculate the y-intercept.
counter = 0
#Establish the counter for the below loop used to calculate
#the R-squared value.
n = len(TNlist[0])
#Store the number of values used in the Total Nitrogen calibration.
productofxandy = []
#Initialize a list to store the product of the x and y values.
xs = []
#Initialize a list to store the x values.
ys = []
#Initialize a list to store the y values.
xsquared = []
#Initialize a list to store the squares of the x values.
ysquared = []
#Initialize a list to store the squares of the y values.
for i in TNlist[0]:
#for each x-value in the Total Nitrogen calibration values:
	productofxandy.append(TNlist[0][counter]*TNlist[1][counter])
        #Calculate the product of the x- and y-values for each point
	xs.append(TNlist[0][counter])
	#Append the x-value to the xs list.
	ys.append(TNlist[1][counter])
	#Append the y-value to the ys list.
	xsquared.append((TNlist[0][counter])*(TNlist[0][counter]))
        #Calculate the square of the x-value.
	ysquared.append((TNlist[1][counter])*(TNlist[1][counter]))
        #Calculate the square of the y-value.
	counter = counter + 1
	#Reset the counter for the next iteration of the loop.
rsquaredTN = (((n*sum(productofxandy))-(sum(xs)*sum(ys)))/math.sqrt(((n*sum(xsquared))-(sum(xs)*sum(xs)))*((n*sum(ysquared))-(sum(ys)*sum(ys)))))**2
#Calculate the R-squared value for the Total Nitrogen calibration curve.

#The following section of the code calculates the values of the chemical
#species in each reading of each sample using the slope and y-intercept of the line of
#best fit for the respective chemical species.
TotalCarbon = [[],[]]
#Initialize a two-dimensional list to store the sample name and
#the Area measured for that sample.
DOC = [[],[]]
#Intialize a two-dimensional list to store the sample name and
#the Area measured for that sample.
TotalNitrogen = [[],[]]
#Initialize a two-dimensional list to store the sample name and
#the Area measured for that sample.
InFile = open(FileName, 'r')
#Read in specified for another loop.
LineNumber = 1
#Establish a linecounter for the following loop.
for Line in InFile:
#for each line in the input file:
	if LineNumber < 15:
	#if the line is a header line:
		pass
		#pass over it.
	else:
	#otherwise,
		Line = Line.strip("\n")
		#Strip the end-of-line break from the line.
		Line = Line.split("\t")
		#Split the line into list elements based upon the
		#location of tabs.
		if Line[1] == "TC" and Line[15] == '0':
		#if the Analysis is Total Carbon AND the sample was included
		#by the machine:
			if Line[2] == "CALIBRATION" or Line[2] == "Water Rinse":
				pass
			#Pass over the row if its a Calibration or Water Rinse recording.
			else:
			#Otherwise,
				TotalCarbon[0].append(Line[2])
				#Append the sample name to the TotalCarbon list.
				TotalCarbon[1].append((float(Line[11]) + yintTC)/slopeTC)
				#Use the slope, y-intercept, and Area to calculate
				#the concentration of total carbon.
		if Line[1] == "NPOC" and Line[15]=='0':
		#if the Analysis is NPOC AND the sample was included by the
		#machine:
			if Line[2] == "CALIBRATION" or Line[2] == "Water Rinse":
				pass
			#Pass over the row if its a Calibration or Water Rinse recording.
			else:
			#otherwise,
				DOC[0].append(Line[2])
				#Append the sample name to the organic carbon list.
				DOC[1].append((float(Line[11]) + yintNPOC)/slopeNPOC)
				#Use the slope, y-intercept, and Area to caculate
				#the concentration of organic carbon.
		if Line[1] == "TN" and Line[15]=='0':
		#if the Analysis is Total Nitrogen and the sample was included by the
		#machine:
			if Line[2] == "CALIBRATION" or Line[2] == "Water Rinse":
				pass
			#Pass over the row if its a Calibration or Water Rinse recording.
			else:
			#otherwise,
				TotalNitrogen[0].append(Line[2])
				#Append the sample name to the total nitrogen list.
				TotalNitrogen[1].append((float(Line[11]) + yintTN)/slopeTN)
				#Use the slope, y-intercept, and Area to calculate
				#the concentration of total nitrogen.
	LineNumber = LineNumber + 1
	#Reset the linenumber for the next iteration of the loop.

#The following section of code calculates the average concentration of each chemical species
#in each sample. This average is calculated because there are 2 included readings from each
#sample.
counter = 0
#Establish the counter for the following loop.
TotalCarbonaveraged = [[],[]]
#Initialize a list to store the average total carbon concentration for each sample.
for i in TotalCarbon[0]:
#for each Total Carbon reading:
	if counter % 2 == 0:
	#Because two consecutive readings from each sample are stored in the Total
	#Carbon list, the code only selects even number rows and then averages
	#the reading from that row with the row that follows it.
		average = ((TotalCarbon[1][counter])+(TotalCarbon[1][counter + 1]))/2
		#Calculate the average of the readings for each sample.
		TotalCarbonaveraged[0].append(i)
		#Append the name of the sample to the TotalCarbonaveraged list.
		TotalCarbonaveraged[1].append(average)
		#Append the calculated average to the list as well.
	else:
		pass
	#If the row is an odd-numbered row, pass over it.
	counter = counter + 1
	#Reset the counter for the next iteration of the loop.
counter = 0
#Set the counter for the following loop.
DOCaveraged = [[],[]]
#Initialize a list that stores the calculated average organic carbon concentration
#for each sample.
for i in DOC[0]:
#for each organic carbon reading:
	if counter % 2 == 0:
	#Because two consecutive readings from each sample are stored in the organic
	#carbon list, the code only selects even number rows and then averages
	#the reading from that row with the row that follows it.
		average = ((DOC[1][counter])+(DOC[1][counter + 1]))/2
		#Calculate the average of the readings for each sample.
		DOCaveraged[0].append(i)
		#Append the name of the sample to the DOCaveraged list.
		DOCaveraged[1].append(average)
		#Append the calculated average to the list as well.
	else:
		pass
	#If the row is an odd-numbered row, pass over it.
	counter = counter + 1
	#Reset the counter for the next iteration of the loop.
counter = 0
#Set the counter for the following loop.
TNaveraged = [[],[]]
#Initialize a list that stores the calculated average total nitrogen concentration
#for each sample.
for i in TotalNitrogen[0]:
#for each total nitrogen reading:
	if counter % 2 == 0:
	#Because two consecutive readings from each sample are stored in the total
	#nitrogen list, the code only selects even number row and then averages
	#the reading from that row with the row that follows it.
		average = ((TotalNitrogen[1][counter])+(TotalNitrogen[1][counter + 1]))/2
		#Calculate the average of the readings for each sample.
		TNaveraged[0].append(i)
		#Append the name of the sample to the TNaveraged list.
		TNaveraged[1].append(average)
		#Append the calculated average to the list as well.
	else:
		pass
	#If the row is an odd-numbered row, pass over it.
	counter = counter + 1
	#Reset the counter for the next iteration of the loop.

#The following section of the code prepares the calculations for output to a csv:
TCCounter = 0
#Establish a counter for the following loop.
print("Sample, TC(ppm), TOC(ppm), TIC(ppm), TN(ppb)")
OutFile.write("Sample, TC(ppm), TOC(ppm), TIC(ppm), TN(ppb)" +"\n")
#Prints a header for the outputted .csv file.
for x in TotalCarbonaveraged[0]:
	#for each sample stored in the TotalCarbonaveraged list:
	DOCCounter = 0
	for y in DOCaveraged[0]:
	#Loop through the samples stored in the DOCaveraged list:
		TNCounter = 0
		for z in TNaveraged[0]:
		#And loop through the samples stored in the TNaveraged list:
			if x == y == z:
			#If the sample name is the same:
				towrite = ("%s, %f, %f, %f, %f" %(x, float(TotalCarbonaveraged[1][TCCounter]), float(DOCaveraged[1][DOCCounter]), float(TotalCarbonaveraged[1][TCCounter])-float(DOCaveraged[1][DOCCounter]), float(TNaveraged[1][TNCounter])))
				print(towrite)
				OutFile.write(towrite + "\n")
				#Prints the sample name, the Total Carbon concentration (ppm),
				#the organic carbon concentration (ppm),
				#calculates and prints the inorganic carbon concentration by calculating
				#the difference between total carbon and organic carbon,
				#and the concentration of total nitrogen. It prints this information to
				#one line separated by commas. It also writes this to the output .csv
				#file.
			TNCounter = TNCounter + 1
		DOCCounter = DOCCounter + 1
	TCCounter = TCCounter + 1
printstatement1 = ("TC Calibration Curve R^2: %f" %(rsquaredTC))
print(printstatement1)
OutFile.write(printstatement1 + "\n")
printstatement2 = ("NPOC Calibration Curve R^2: %f" %(rsquaredNPOC))
print(printstatement2)
OutFile.write(printstatement2 + "\n")
printstatement3 = ("TN Calibration Curve R^2: %f" % (rsquaredTN))
print(printstatement3)
OutFile.write("TN Calibration Curve R^2: %f" % (rsquaredTN) + "\n")
#Print the R-squared values for each of the calibration curves at the bottom of the .csv file
#and print the output to screen.
InFile.close()
OutFile.close()
